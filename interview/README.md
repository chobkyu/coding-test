## Nodejs
<hr/>

### nodejs 특징
1. 비동기 i/o : 비동기 이벤트 기반 프로그래밍 모델을 사용하므로 i/o 작업을 동기적으로 처리하지 않고 비동기적으로 처리할 수 있음
2. 빠른 속도 : V8 자바스크립트 엔진을 사용하여 빠른 속도로 코드를 실행. 이벤트 루프와 함께 작동하여 더 빠른 속도 제공
3. 싱글 스레드 : 단일 스레드 모델을 사용하므로 스레드 간 동기화 문제를 피할 수 있다.

### nodejs의 동작원리 및 득징
chrome v8 엔진으로 빌드 된 자바스크립트 런타임. 싱글스레드 기반으로 논 블로킹, 이벤트 기반의 특징을 가진다.

노드는 사용자가 제어 가능한 스레드가 한개인 싱글 스레드 기반이고 메인 스레드를 통해 자바스크립트 코드를 처리
하게 되는데 클라이언트 요청이 들어오면 nodejs는 이를 이벤트 큐에 넣게 된다.
메인 스레드가 이벤트 큐의 요청을 순차적으로 처리하는데 동기 작업은 즉시 실행된다.
그러자 비동기작업을 만나면 이벤트루프가 해당 작업을 백그라운드 스레드로 보내게 된다.
백그라운드에서 워커 스레드로 처리하고 작업이 끝난 후 콜백함수를 다시 이벤트 큐에 등록한다.
그러면 마지막으로 이벤트 루프가 이벤트 큐에 등록된 콜백 함수를 다시 메인 스레드로 올리는 역할을 하게 된다.


### 비동기 이벤트 기반 프로그래밍 모델이란
비동기 이벤트 기반 프로그래밍 모델은 이벤트가 발생할 때마다 이를 처리하기 위한 콜백 함수를 등록해놓고, 이벤트
가 발생하면 등록된 콜백 함수를 실행하는 방식으로 동작.

이 모델은 비동기 처리 방식으로 동작하며, 즉시 처리해야 하는 작업이 아닌 이벤트가 발생할 때까지 대기하며, 이벤트
발생 시 즉시 처리한다. 이런 방식은 i/o 작업 등의 느린 작업을 처리할 때 매우 효율적

대표적으로 웹 서버에서 요청이 들어올 때마다 콜백 함수를 등록하여 처리하는 방식이 있다. 이 모델은 nodejs에서 제공하는
이벤트 루프를 기반으로 동작한다.

### 싱글스레드인데 어떻게 비동기 처리가 가능한가?
기본적으로 싱글스레드에서 동작한다. 이벤트 루프를 포함한 node.js의 핵심 요소들은 단일 스레드에서 동작하며, 이벤트루프는
단일 스레드에서 순차적으로 작업을 처리한다.

다만 노드에서는 v8 엔진을 포함하여 다른 모듈 및 기능들도 함께 사용되므로 전체적인 실행환경에서는 단일 스레드
이외에도 멀티 스레드가 사용된다.

백그라운드 스레드는 nodejs의 i/o 작업 및 비동기 작업 처리를 위해 사용된다. 백그라운드 스레드는 기본 스레드와 별개의
스레드에서 실행되므로 nodejs의 기본 스레드는 여전히 단일 스레드입니다. 백그라운드 스레드는 내부적으로 스레드 풀을
사용하여 i/o 작업을 병렬로 처리하므로 블로킹을 방지할 수 있다. 따라서 기본적으로 싱글 스레드에서 동작하지만
백그라운드 스레드와 같은 다른 스레드를 사용하여 비동기 작업 처리를 지원하고 있다.


## 자바스크립트
<hr/>

## CS
<hr/>

### 프로세스와 스레드는 무엇인가요?
프로세스는 메모리에 올라가 실행 중인 프로그램, 프로세스마다 자신만의 주소공간, 데이터 등의 자원을 가지고 있음
스레드는 프로세스 안에서 동작하는 작업의 단위로써 스레드끼리 프로세스 안의 자원을 공유하고 동시에 실행되기 때문에 성능을 향상 시킬 수 있다.
다만 자원을 공유하고 동시에 실행되기 때문에 동시성 문제가 발생할 수 있다.


### 컨텍스트 스위칭
cpu에서 현재 작업 중인 프로세스 또는 스레드와 다음 실행할 프로세스 및 스레드 간의 실행 상태를 전환하는 작업.
현재 실행 중인 작업의 상태를 저장하고 다음 작업의 상태를 로드하여 전환하는 과정


### restful api
자원을 이름으로 구분하여 http 프로토콜로 해당 자원을 주고 받는 api
- get: 리소스 조회
- post: 데이터 추가, 등록
- put: 리소스 대체, 수정/ 해당 리소스가 없으면 새로 생성 
- delete: 삭제
- patch: 리소스 부분 수정


### 쿠키와 세션의 차이점
쿠키는 클라이언트에 저장되는 작은 텍스트 파일로, 웹사이트 방문 기록, 사용자의 로그인 정보 등을 저장할 수 있다.
세션은 클라이언트가 서버에 접속할 때 서버에서 생성되는 고유한 정보이다. 세션은 일반적으로 쿠키를 이용하여
클라이언트의 고유한 ID(스프링에서의 jsessionid 같은)를 부여하고 이 id를 서버에서 관리. 세션은 보안성이 더 높고 
서버에서 관리하기 때문에 쿠키보다 안전하다.

### 캐싱이란?
빠른 데이터 검색을 위해 자주 사용되는 데이터를 미리 복사해놓는 것을 말함. 캐싱은 데이터의 응답속도를 높이고, 처리 속도를 개선하기 위해 사용

캐시된 데이터는 미리 복사해놓기 때문에, 데이터 검색 시 원래 데이터베이스에서 검색하는 것보다 빠른 속도 제공
따라서 사용자 경험을 개선하고 데이터베이스에 대한 요청 수가 줄어들기 때문에 시스템 부하가 감소한다.

다만 데이터의 일관성과 무결성을 유지하는 것이 중요하다. 캐시된 데이터가 원본 데이터와 다른 경우, 데이터의 
무결성이 깨질 수 있으므로 적절한 캐싱 전략을 수립하고 관리하는 것이 중요하다.

### jwt란?
jwt는 인터넷에서 정보를 안전하게 전송하기 위한 인증 방식 중 하나. jwt는 json 형식으로 데이터를 저장하며, 데이터의 무결성을 보장하기 위해 디지털 서명이 포함

로그인을 하면 서버에서 jwt를 발급하고 이 jwt를 사용하여 사용자 인증 정보를 안전하게 전송할 수 있다.

jwt는 다음과 같은 구성 요소로 이루어져 있다.

- header - jwt에 대한 메타 정보 포함
- payload - jwt에 저장될 정보가 포함된다. 대표적으로 사용자 아이디, 권한 정보 등이 있다.
- signatue - jwt의 무결성을 보장하기 위한 디지털 서명이 포함된다. 서명은 secret key를 사용하여 생성되며 이를 통해 jwt가 변조되지 않았는지 검증할 수 있다

세션과 유사한 역할을 수행할 수 있지만 세션과는 달리 jwt는 서버의 메모리를 사용하지 않는다.
따라서 서버 확장성이 더욱 용이하며 사용자가 다른 서버로 이동해도 인증 정보를 유지할 수 있다.

다만 탈취 당했을 때 막을 수 있는 방법이 없기 때문에 적절한 유효시간 선정이 필요하다


### CORS란?
CORS는 추가 HTTP 헤더를 사용하여 한 출처에서 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제. 예를 들어 AJAX, Fetch API는 동일 출처 정책을 따르는데 자신의 출처와 동일한 리소스만 불러올 수 있으며 다른 출처의 리소스를 불러오려면 그 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 한다.

허용방법은 크게 두가지인데 직접 헤더를 명시해서 출처를 필터링하는 것이고 다른 하나는 CORS 노드 패키지를 사용해 좀 더 간편하면서 유기적으로 출처를 필터링 할 수 있다.


### 웹서버와 was의 차이
웹 서버와 was는 모두 클라이언트의 요청에 대한 응답을 제공하는 서버이다. 그러나 두 서버 간에는 몇 가지 차이가 있다

웹 서버는 웹 페이지와 같은 정적인 컨텐츠를 제공하는 서버이다. 대표적으로 apache, nginx 등이 있다.
웹 서버는 정적인 컨텐츠를 처리하기 때문에 html, css, javascript와 같은 파일을 처리하는데 적합하다.
또한 웹 서버는 프로그램 실행에 필요한 환경을 제공하지 않기 대문에 웹서버 자체로는 동적인 컨텐츠를 처리할 수 없다.

반면에 was는 동적인 컨텐츠를 처리하는데 적합한 서버. 대표적인 예로는 tomcat 등이 있다. was는 웹서버와는 달리
프로그램 실행에 필요한 환경을 제공하며, 다양한 언어와 프레임워클 지원

was는 동적인 컨텐츠를 처리하며 분산처리를 지원하며 서버의 확장성을 높일 수 있다. 또 보안 기능을 제공하며
사용자 인증, 권한 부여, 데이터 암호화 등의 기능을 제공. 


### 시간 복잡도와 공간복잡도의 차이
특정 크기의 데이터가 입력 되었을 때 어떤 문제를 해결하는데 걸리는 알고리즘의 수행 시간이 시간 복잡도이고 해당 알고리즘이 수행하는 동안의 메모리 사용량이 공간 복잡도를 의미한다. 이러한 복잡도라는 척도를 통해 특정 알고리즘의 성능을 평가할 수 있는데 과거 메모리 공간이 부족하던 때와 달리 컴퓨터 성능의 발달로 공간 복잡도보다는 시간 복잡도를 중심으로 프로그래밍을 작성한다.


## 알고리즘 / 자료 구조
<hr/>

### stack, queue
스택은 책을 쌓는 것처럼 차곡차곡 쌓아올린 형태의 자료구조. 스택에서 가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있으며, 삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이고 삭제도 top에서 됩니다. 이러한 스택의 구조를 후입선출 (LIFO, Last-In-First-Out) 구조라고 한다.

큐는 은행에서 먼저 온 사람의 업무를 창구에서 처리하는 것과 같이 선입선출 (FIFO, First in first out) 방식의 자료구조이다. 큐는 한쪽 끝에서 삽입 작업이, 다른 쪽 끝에서 삭제 작업이 양쪽으로 이루어진다.


### array, linked list
배열은 연속된 메모리 공간에 존재하고 linked-list는 메모리 상에서 떨어져 있는 데이터들이 앞의 데이터와 뒤의 데이터를 기억하는 형태로 존재한다. 배열이 요소에 접근할 때의 시간 복잡도는 O(1) 이다. 반면 Linked List의 시간 복잡도는 O(n)이다. 배열에서 삽입 및 삭제할 때의 시간 복잡도는 O(n)이지만 linked-list의 시간복잡도는 O(1)이다. 따라서 데이터 접근이 주된 목적일 때는 배열이 유리하고 데이터 삽입, 삭제, 수정이 주 목적일 땐 linked-list가 유리하다. 배열의 경우 새로운 데이터를 삽입하려면 기존 데이터를 이동시켜야 하지만 링크드 리스트에서는 새로운 노드를 만들어서 연결시키면 된다.


### 이진탐색이 무엇이고 시간복잡도는 어떻게 되며 그 이유는 무엇인지?
이분탐색은 정렬된 목록에서 특정 값을 찾는 방법입니다. 목록의 중간값을 확인하고 찾는 값이 중간값보다 큰지 작은지를 비교하여 검색 범위를 반으로 줄여나가는 방식으로 진행됩니다. 이 방법은 전체 목록을 검색하는 것보다 훨씬 빠르게 값을 찾을 수 있습니다. 이분탐색의 시간복잡도는 O(logN)입니다. 이는 이분탐색이 검색 범위를 절반씩 줄여나가기 때문에 전체 데이터의 수 N에 따라 시행 횟수가 logN이 되기 때문입니다. 즉, 검색 범위가 절반씩 줄어들기 때문에 검색 속도가 빠르게 진행됩니다.

### 트리, 그래프 비교
트리와 그래프는 모두 노드와 간선으로 구성된 데이터 구조입니다. 하지만 트리는 계층적인 구조를 가지며 루트 노드가 존재하고, 각 노드는 하나의 부모 노드만을 가집니다. 반면 그래프는 루트 노드의 개념이 없으며, 각 노드는 여러 개의 부모 노드를 가질 수 있습니다. 트리는 사이클이 없는 하나의 연결 그래프입니다.


### OOP
객체지향 프로그래밍으로 프로그래밍 패러다임 중 하나. 객체 지향 프로그래밍은 데이터와 기능을 객체라는 개념으로 묶어서 프로그래밍하는 방식으로 코드의 재사용성과 유지보수성을 높이는 것을 지향한다.

## 데이터베이스
<hr/>

### inner join, left join 차이
inner 조인은 교집합이라고 할 수 있다. 오로지 조건에 맞는 부분만이 select가 된다.
left join은 왼쪽 테이블에 따라 모든 레코드를 반환하고 오른쪽 테이블과 조건에 맞는 레코드가 있으면 함께 반환
없으면 null. 따라서 왼쪽 테이블의 데이터가 적은 것을 기준으로 삼는게 유리하다


### 인덱스란 무엇인가
데이터베이스에서 검색 속도를 높이기 위한 데이터 구조. 테이블 내의 하나 이상의 열을 기준으로 정렬된 데이터 세트
대개 트리 등의 알로기리즘을 사용하여 구현. 인덱스는 서치에는 좋지만 디비의 용량을 늘리고 데이터 입력/수정/삭제
에 소요되는 시간을 증가시킬 수 있다. 물론 인덱스는 데이터를 그대로 복사하는게 아니라 인덱스랑 키 값만 복사하기 때문에
무작정 용량이 몇 배로 늘어나지는 않는다.

### 인덱스의 종류
b-tree 인덱스: 대부분의 관계형 데이터베이스에서 사용되는 인덱스로, 데이터가 정렬된 상태로 저장
hash 인덱스: 해시 테이블을 이용하여 데이터를 인덱싱 하며, 특정 값의 빠른 검색에 유리

### 트랜잭션
트랜잭션은 데이터베이스에서 하나의 논리적인 작업 단위를 이루는 일련의 연산.
트랜잭션은 일관성과 무결성을 유지하기 위해 모두 성공하거나 모두 실패해야 함

### ACID
Atomicity(원자성): 트랜잭션의 모든 연산이 성공하거나 모두 실패해야 합니다.
Consistency(일관성): 트랜잭션 전후에 데이터베이스는 일관된 상태를 유지해야 합니다.
Isolation(격리성): 트랜잭션 간의 상호 간섭을 방지해야 합니다.
Durability(지속성): 트랜잭션 완료 후 변경된 데이터는 영구적으로 저장되어야 합니다.

### isolation level
- read uncommitted: 트랜잭션이 커밋되지 않은 변경 사항을 다른 트랜잭션이 읽을 수 있습니다. **Dirty Read (더티 리드)**가 발생할 수 있습니다. 이는 수정이 롤백될 경우 잘못된 데이터를 읽게 되는 문제입니다.
- read committed: 트랜잭션이 커밋된 데이터만 다른 트랜잭션이 읽을 수 있습니다. , **Non-Repeatable Read (반복 불가능한 읽기)**가 발생할 수 있습니다.
예: 트랜잭션 A가 데이터를 읽는 동안, 트랜잭션 B가 데이터를 변경하면, A가 다시 읽을 때 데이터가 달라질 수 있음.
- repeatable read: 트랜잭션 내에서 동일한 쿼리를 여러 번 실행해도 동일한 결과를 반환합니다. 읽은 데이터가 다른 트랜잭션에서 변경되거나 삭제되지 못하도록 차단합니다. Dirty Read와 Non-Repeatable Read를 방지합니다. 하지만 **Phantom Read (팬텀 리드)**는 발생할 수 있습니다.
예: 트랜잭션 A가 특정 조건을 만족하는 행을 조회했을 때, 트랜잭션 B가 새로운 행을 삽입하면 A가 다시 조회할 때 추가된 행이 나타날 수 있음.
- serializable: 가장 높은 격리 수준으로, 트랜잭션이 순차적으로 실행되는 것처럼 동작합니다. 성능이 크게 저하될 수 있음. 특히 동시 실행이 많은 환경에서 병목 현상 발생 가능.
